Error: assignment.js:16
 16:   while (x = x.parent) { // can't assign x to ?Bar
                  ^^^^^^^^ Cannot assign `x.parent` to `x` because null or undefined [1] is incompatible with `Bar` [2].
  References:
   11:   parent: ?Bar;
                 ^^^^ [1]: null or undefined
   15: function bar0(x : Bar) {
                         ^^^ [2]: `Bar`

Error: assignment.js:16
 16:   while (x = x.parent) { // can't assign x to ?Bar
                  ^^^^^^^^ null or undefined [1] is incompatible with `Bar` [2].
  References:
   11:   parent: ?Bar;
                 ^^^^ [1]: null or undefined
   15: function bar0(x : Bar) {
                         ^^^ [2]: `Bar`

Error: assignment.js:22
 22:   while (x = x.parent) { // x.parent might be null
                    ^^^^^^ Cannot get `x.parent` because property `parent` is missing in null or undefined [1].
  References:
   21: function bar1(x : ?Bar) {
                         ^^^^ [1]: null or undefined

Error: bool.js:12
 12:   x[0]; // error on null and undefined
         ^ Cannot get `x[0]` because an indexer property is missing in null or undefined [1].
  References:
    3: function foo(x: ?bool) {
                       ^^^^^ [1]: null or undefined

Error: bool.js:18
 18:       x[0]; // error on null and undefined
             ^ Cannot get `x[0]` because an indexer property is missing in null or undefined [1].
  References:
   15: function bar(x: ?bool) {
                       ^^^^^ [1]: null or undefined

Error: bool.js:24
 24:   if (100 * false) {
                 ^^^^^ boolean. The operand of an arithmetic operation must be a number.

Error: bool.js:27
 27:   if (false * 100) {
           ^^^^^ boolean. The operand of an arithmetic operation must be a number.

Error: bool.js:37
 37:     return x.result; // error
                  ^^^^^^ Cannot get `x.result` because property `result` is missing in object type [1].
  References:
   33:   function(x: { done: true, result: string } | { done: false }) {
                                                      ^^^^^^^^^^^^^^^ [1]: object type

Error: bool.js:44
 44:     return x.result; // error
                  ^^^^^^ Cannot get `x.result` because property `result` is missing in object type [1].
  References:
   40:   function(x: { done: true, result: string } | { done: false }) {
                                                      ^^^^^^^^^^^^^^^ [1]: object type

Error: cond_prop.js:11
 11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                             ^^^^^^^^^^^^ BadType. This type is incompatible with the expected param type of
  9: function getTypeASTName(typeAST: Type): string {
                                      ^^^^ union: `Name` | `ListType` | `NonNullType`
  Member 1:
    3: type Type = Name | ListType | NonNullType;
                   ^^^^ Name
  Error:
   11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                               ^^^^^^^^^^^^ BadType. This type is incompatible with
    3: type Type = Name | ListType | NonNullType;
                   ^^^^ Name
    Property `kind` is incompatible:
        3: type Type = Name | ListType | NonNullType;
                       ^^^^ property `kind`. Property not found in
       11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                                   ^^^^^^^^^^^^ BadType
  Member 2:
    3: type Type = Name | ListType | NonNullType;
                          ^^^^^^^^ ListType
  Error:
   11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                               ^^^^^^^^^^^^ BadType. This type is incompatible with
    3: type Type = Name | ListType | NonNullType;
                          ^^^^^^^^ ListType
    Property `kind` is incompatible:
        3: type Type = Name | ListType | NonNullType;
                              ^^^^^^^^ property `kind`. Property not found in
       11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                                   ^^^^^^^^^^^^ BadType
  Member 3:
    3: type Type = Name | ListType | NonNullType;
                                     ^^^^^^^^^^^ NonNullType
  Error:
   11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                               ^^^^^^^^^^^^ BadType. This type is incompatible with
    3: type Type = Name | ListType | NonNullType;
                                     ^^^^^^^^^^^ NonNullType
    Property `kind` is incompatible:
        3: type Type = Name | ListType | NonNullType;
                                         ^^^^^^^^^^^ property `kind`. Property not found in
       11:   return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type
                                   ^^^^^^^^^^^^ BadType

Error: cond_prop.js:19
 19:     return x.result; // error
                  ^^^^^^ Cannot get `x.result` because property `result` is missing in object type [1].
  References:
   15:   function(x: { done: true, result: string } | { done: false }) {
                                                      ^^^^^^^^^^^^^^^ [1]: object type

Error: cond_prop.js:24
 24:       return x.result; // error, consider { foo: "herp", done: "derp" }
                    ^^^^^^ Cannot get `x.result` because property `result` is missing in object type [1].
  References:
   22:   function(x: { done: true, result: string } | { foo: string }) {
                                                      ^^^^^^^^^^^^^^^ [1]: object type

Error: cond_prop.js:26
 26:     return x.result; // error
                  ^^^^^^ Cannot get `x.result` because property `result` is missing in object type [1].
  References:
   22:   function(x: { done: true, result: string } | { foo: string }) {
                                                      ^^^^^^^^^^^^^^^ [1]: object type

Error: cond_prop.js:36
 36:         (t.bar: string); // error, consider { baz: "x", quux: "y", foo: "boom" }
                ^^^ Cannot get `t.bar` because property `bar` is missing in object type [1].
  References:
   34:     function testAlwaysTruthyProp(t: T) {
                                            ^ [1]: object type

Error: cond_prop.js:46
 46:         (t.foo: Object); // error, consider { baz: "x", quux: "y", bar: "boom" }
                ^^^ Cannot get `t.foo` because property `foo` is missing in object type [1].
  References:
   44:     function testSometimesTruthyProp(t: T) {
                                               ^ [1]: object type

Error: cond_prop.js:48
 48:         (t.quux: string); // error, consider { foo: {}, bar: "" }
                ^^^^ Cannot get `t.quux` because property `quux` is missing in object type [1].
  References:
   44:     function testSometimesTruthyProp(t: T) {
                                               ^ [1]: object type

Error: cond_prop.js:54
 54:     if (o.p) {} // error: property `p` not found on null
               ^ Property `p` is missing in null [1].
  References:
   53:   function(o: null|{}) {
                     ^^^^ [1]: null

Error: eq.js:5
  5:     if (x == y) {} // error, string & number are not comparable (unsafe casting)
             ^ string. This type cannot be compared to
  5:     if (x == y) {} // error, string & number are not comparable (unsafe casting)
                  ^ number

Error: eq.js:19
 19:     if (x.y == 123) {} // error
             ^^^ string literal `bar`. This type cannot be compared to
 19:     if (x.y == 123) {} // error
                    ^^^ number

Error: eq.js:19
 19:     if (x.y == 123) {} // error
             ^^^ string literal `foo`. This type cannot be compared to
 19:     if (x.y == 123) {} // error
                    ^^^ number

Error: hasOwnProperty.js:4
  4:   x.y(); // error: could be undefined
         ^ Cannot call `x.y` because undefined [1] is not a function.
  References:
    3: function foo(x:{y?:() => void}) {
                          ^^^^^^^^^^ [1]: undefined

Error: hasOwnProperty.js:6
  6:     x.y(); // error: still could be undefined
           ^ Cannot call `x.y` because undefined [1] is not a function.
  References:
    3: function foo(x:{y?:() => void}) {
                          ^^^^^^^^^^ [1]: undefined

Error: hasOwnProperty.js:9
  9:     x.z(); // error: unreachable, but we don't help you here
           ^ Cannot call `x.z` because property `z` is missing in object type [1].
  References:
    3: function foo(x:{y?:() => void}) {
                      ^^^^^^^^^^^^^^^ [1]: object type

Error: heap_defassign.js:10
 10:     var x: number = obj.p;      // error, obj.p : number | string
                         ^^^^^ Cannot assign `obj.p` to `x` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   10:     var x: number = obj.p;      // error, obj.p : number | string
                  ^^^^^^ [2]: number

Error: heap_defassign.js:16
 16:     var x: number = obj.p;      // error, obj.p : number | string
                         ^^^^^ Cannot assign `obj.p` to `x` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   16:     var x: number = obj.p;      // error, obj.p : number | string
                  ^^^^^^ [2]: number

Error: heap_defassign.js:22
 22:     var x: number = obj.p;      // error, obj.p : number | string
                         ^^^^^ Cannot assign `obj.p` to `x` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   22:     var x: number = obj.p;      // error, obj.p : number | string
                  ^^^^^^ [2]: number

Error: heap_defassign.js:30
 30:     var y: number = obj.p;      // error, obj.p : number | string
                         ^^^^^ Cannot assign `obj.p` to `y` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   30:     var y: number = obj.p;      // error, obj.p : number | string
                  ^^^^^^ [2]: number

Error: heap_defassign.js:38
 38:     var y: number = obj.p;      // error, obj.p : number | string
                         ^^^^^ Cannot assign `obj.p` to `y` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   38:     var y: number = obj.p;      // error, obj.p : number | string
                  ^^^^^^ [2]: number

Error: heap_defassign.js:62
 62:         var y: number = obj.p;  // error, string ~/~ number
                             ^^^^^ Cannot assign `obj.p` to `y` because string [1] is incompatible with number [2].
  References:
   53:         obj.p = 'hey';
                       ^^^^^ [1]: string
   62:         var y: number = obj.p;  // error, string ~/~ number
                      ^^^^^^ [2]: number

Error: heap_defassign.js:65
 65:     var z:string = obj.p;       // error, number ~/~ string
                        ^^^^^ Cannot assign `obj.p` to `z` because number [1] is incompatible with string [2].
  References:
   63:         obj.p = 42;
                       ^^ [1]: number
   65:     var z:string = obj.p;       // error, number ~/~ string
                 ^^^^^^ [2]: string

Error: heap_defassign.js:73
 73:     var z: number = obj.p;      // error, (number | string) ~/~ number
                         ^^^^^ Cannot assign `obj.p` to `z` because string [1] is incompatible with number [2].
  References:
    3: type Obj = { p: number | string }
                                ^^^^^^ [1]: string
   73:     var z: number = obj.p;      // error, (number | string) ~/~ number
                  ^^^^^^ [2]: number

Error: missing-property-cond.js:11
 11:     o.p2.x; // error, since o.p2's type is unknown (e.g., could be `number`)
              ^ Cannot get `o.p2.x` because property `x` is missing in property `p2` of unknown type [1].
  References:
   10:   if (o.p2) { // OK
             ^^^^ [1]: property `p2` of unknown type

Error: missing-property-cond.js:16
 16:   o.p3.x; // usual error outside conditional
         ^^ Cannot get `o.p3` because property `p3` is missing in object type [1].
  References:
   15: function foo3(o: { x: number }) {
                        ^^^^^^^^^^^^^ [1]: object type

Error: missing-property-cond.js:23
 23:     o.p4.x; // error
              ^ Cannot get `o.p4.x` because property `x` is missing in property `p4` does not exist [1].
  References:
   20:   if (o.p4) { // OK
             ^^^^ [1]: property `p4` does not exist

Error: missing-property-cond.js:37
 37:   if (o.bar) {} // error, any lookup on mixed is unsafe
             ^^^ Property `bar` is missing in mixed [1].
  References:
   36: function foo6(o: mixed) {
                        ^^^^^ [1]: mixed

Error: missing-property-cond.js:41
 41:   if (typeof o.bar === 'string') {} // error
                    ^^^ Property `bar` is missing in mixed [1].
  References:
   40: function foo7(o: mixed) {
                        ^^^^^ [1]: mixed

Error: missing-property-cond.js:65
 65:   if (null.q) {} // error: property `q` on null
                ^ Property `q` is missing in null [1].
  References:
   65:   if (null.q) {} // error: property `q` on null
             ^^^^ [1]: null

Error: mixed.js:8
  8:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because number [1] is incompatible with string [2].
  References:
    6: function num(x: mixed) {
                       ^^^^^ [1]: number
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:9
  9:     (!x: false); // error: we don't know the truthiness of x
          ^^ Cannot cast `!x` to boolean literal `false` because boolean [1] is incompatible with boolean literal `false` [2].
  References:
    9:     (!x: false); // error: we don't know the truthiness of x
            ^^ [1]: boolean
    9:     (!x: false); // error: we don't know the truthiness of x
                ^^^^^ [2]: boolean literal `false`

Error: mixed.js:21
 21:     takesNumber(x); // error
                     ^ Cannot call `takesNumber` with `x` bound to `x` because string [1] is incompatible with number [2].
  References:
   19: function str(x: mixed) {
                       ^^^^^ [1]: string
    3: function takesNumber(x: number) {}
                               ^^^^^^ [2]: number

Error: mixed.js:22
 22:     (!x: false); // error: we don't know the truthiness of x
          ^^ Cannot cast `!x` to boolean literal `false` because boolean [1] is incompatible with boolean literal `false` [2].
  References:
   22:     (!x: false); // error: we don't know the truthiness of x
            ^^ [1]: boolean
   22:     (!x: false); // error: we don't know the truthiness of x
                ^^^^^ [2]: boolean literal `false`

Error: mixed.js:34
 34:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because boolean [1] is incompatible with string [2].
  References:
   32: function bool(x: mixed) {
                        ^^^^^ [1]: boolean
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:35
 35:     (x: true); // error: we don't know the truthiness of x
          ^ Cannot cast `x` to boolean literal `true` because boolean [1] is incompatible with boolean literal `true` [2].
  References:
   32: function bool(x: mixed) {
                        ^^^^^ [1]: boolean
   35:     (x: true); // error: we don't know the truthiness of x
               ^^^^ [2]: boolean literal `true`

Error: mixed.js:47
 47:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because function [1] is incompatible with string [2].
  References:
   45: function fun(x: mixed) {
                       ^^^^^ [1]: function
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:53
 53:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because null [1] is incompatible with string [2].
  References:
   51: function obj0(x: mixed) {
                        ^^^^^ [1]: null
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:53
 53:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because object [1] is incompatible with string [2].
  References:
   51: function obj0(x: mixed) {
                        ^^^^^ [1]: object
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:59
 59:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because array [1] is incompatible with string [2].
  References:
   57: function obj1(x: mixed) {
                        ^^^^^ [1]: array
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:65
 65:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because undefined [1] is incompatible with string [2].
  References:
   63: function undef(x: mixed) {
                         ^^^^^ [1]: undefined
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:71
 71:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because null [1] is incompatible with string [2].
  References:
   69: function null_(x: mixed) {
                         ^^^^^ [1]: null
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:77
 77:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because null [1] is incompatible with string [2].
  References:
   75: function maybe(x: mixed) {
                         ^^^^^ [1]: null
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:77
 77:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because undefined [1] is incompatible with string [2].
  References:
   75: function maybe(x: mixed) {
                         ^^^^^ [1]: undefined
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:83
 83:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because boolean literal `true` [1] is incompatible with string [2].
  References:
   81: function true_(x: mixed) {
                         ^^^^^ [1]: boolean literal `true`
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:89
 89:     takesString(x); // error
                     ^ Cannot call `takesString` with `x` bound to `x` because boolean literal `false` [1] is incompatible with string [2].
  References:
   87: function false_(x: mixed) {
                          ^^^^^ [1]: boolean literal `false`
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: mixed.js:97
 97:       (x['foo']: string); // error, mixed
            ^^^^^^^^ Cannot cast `x['foo']` to string because mixed [1] is incompatible with string [2].
  References:
   93: function obj2(x: mixed) {
                        ^^^^^ [1]: mixed
   97:       (x['foo']: string); // error, mixed
                        ^^^^^^ [2]: string

Error: mixed.js:119
119:     takesString(x[0]); // error
                     ^^^^ Cannot call `takesString` with `x[0]` bound to `x` because mixed [1] is incompatible with string [2].
  References:
  117: function arr0(x: mixed) {
                        ^^^^^ [1]: mixed
    4: function takesString(x: string) {}
                               ^^^^^^ [2]: string

Error: not.js:5
  5:     x++; // should error for null, void and bool (false)
         ^ boolean. The operand of an arithmetic operation must be a number.

Error: not.js:5
  5:     x++; // should error for null, void and bool (false)
         ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: not.js:5
  5:     x++; // should error for null, void and bool (false)
         ^^^ Cannot assign number to `x` because number [1] is incompatible with boolean [2].
  References:
    5:     x++; // should error for null, void and bool (false)
           ^^^ [1]: number
    3: function foo(x: ?bool) {
                        ^^^^ [2]: boolean

Error: not.js:5
  5:     x++; // should error for null, void and bool (false)
         ^^^ number [1] is incompatible with boolean [2].
  References:
    5:     x++; // should error for null, void and bool (false)
           ^^^ [1]: number
    3: function foo(x: ?bool) {
                        ^^^^ [2]: boolean

Error: not.js:11
 11:     x[0]; // should error for null, void and number (0)
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Number` [1].
  References:
    9: function bar(x: ?number) {
                        ^^^^^^ [1]: `Number`

Error: not.js:11
 11:     x[0]; // should error for null, void and number (0)
           ^ Cannot get `x[0]` because an indexer property is missing in null or undefined [1].
  References:
    9: function bar(x: ?number) {
                       ^^^^^^^ [1]: null or undefined

Error: not.js:21
 21:     x[0]; // should error for number (0)
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Number` [1].
  References:
   15: function baz (x: ?number) {
                         ^^^^^^ [1]: `Number`

Error: not.js:41
 41:     (!x: false); // error, strings are not always truthy
          ^^ Cannot cast `!x` to boolean literal `false` because boolean [1] is incompatible with boolean literal `false` [2].
  References:
   41:     (!x: false); // error, strings are not always truthy
            ^^ [1]: boolean
   41:     (!x: false); // error, strings are not always truthy
                ^^^^^ [2]: boolean literal `false`

Error: not.js:44
 44:     (!x: false); // error, numbers are not always truthy
          ^^ Cannot cast `!x` to boolean literal `false` because boolean [1] is incompatible with boolean literal `false` [2].
  References:
   44:     (!x: false); // error, numbers are not always truthy
            ^^ [1]: boolean
   44:     (!x: false); // error, numbers are not always truthy
                ^^^^^ [2]: boolean literal `false`

Error: not.js:47
 47:     (!x: false); // error, bools are not always truthy
          ^^ Cannot cast `!x` to boolean literal `false` because boolean [1] is incompatible with boolean literal `false` [2].
  References:
   47:     (!x: false); // error, bools are not always truthy
            ^^ [1]: boolean
   47:     (!x: false); // error, bools are not always truthy
                ^^^^^ [2]: boolean literal `false`

Error: null.js:4
  4:   if (100 * null) {
                 ^^^^ null. The operand of an arithmetic operation must be a number.

Error: null.js:7
  7:   if (null * 100) {
           ^^^^ null. The operand of an arithmetic operation must be a number.

Error: number.js:8
  8:       (x: void); // error
            ^ Cannot cast `x` to undefined because number literal `0` [1] is incompatible with undefined [2].
  References:
    6:   function(x: number) {
                     ^^^^^^ [1]: number literal `0`
    8:       (x: void); // error
                 ^^^^ [2]: undefined

Error: number.js:10
 10:     (x: 0); // error
          ^ Cannot cast `x` to number literal `0` because number [1] is incompatible with number literal `0` [2].
  References:
    6:   function(x: number) {
                     ^^^^^^ [1]: number
   10:     (x: 0); // error
               ^ [2]: number literal `0`

Error: number.js:15
 15:       (x: 0); // error
            ^ Cannot cast `x` to number literal `0` because number [1] is incompatible with number literal `0` [2].
  References:
   13:   function(x: number) {
                     ^^^^^^ [1]: number
   15:       (x: 0); // error
                 ^ [2]: number literal `0`

Error: number.js:17
 17:     (x: void); // error
          ^ Cannot cast `x` to undefined because number [1] is incompatible with undefined [2].
  References:
   13:   function(x: number) {
                     ^^^^^^ [1]: number
   17:     (x: void); // error
               ^^^^ [2]: undefined

Error: number.js:21
 21:     if (x === 0) {
                   ^ number literal `0` [1] is incompatible with number literal `1` [2].
  References:
   21:     if (x === 0) {
                     ^ [1]: number literal `0`
   20:   function(x: 1): 0 {
                     ^ [2]: number literal `1`

Error: number.js:28
 28:     if (x === 1) {
                   ^ number literal `1` [1] is incompatible with number literal `0` [2].
  References:
   28:     if (x === 1) {
                     ^ [1]: number literal `1`
   27:   function(x: 0): number {
                     ^ [2]: number literal `0`

Error: number.js:35
 35:     if (x !== 1) {
                   ^ number literal `1` [1] is incompatible with number literal `0` [2].
  References:
   35:     if (x !== 1) {
                     ^ [1]: number literal `1`
   34:   function(x: 0) {
                     ^ [2]: number literal `0`

Error: number.js:51
 51:       (x: void); // error
            ^ Cannot cast `x` to undefined because number literal `0` [1] is incompatible with undefined [2].
  References:
   48:   function(x: 0 | 1) {
                     ^ [1]: number literal `0`
   51:       (x: void); // error
                 ^^^^ [2]: undefined

Error: number.js:51
 51:       (x: void); // error
            ^ Cannot cast `x` to undefined because number literal `0` [1] is incompatible with undefined [2].
  References:
   49:     if (x === 0) {
                     ^ [1]: number literal `0`
   51:       (x: void); // error
                 ^^^^ [2]: undefined

Error: number.js:55
 55:       (x: void); // error
            ^ Cannot cast `x` to undefined because number literal `1` [1] is incompatible with undefined [2].
  References:
   48:   function(x: 0 | 1) {
                         ^ [1]: number literal `1`
   55:       (x: void); // error
                 ^^^^ [2]: undefined

Error: number.js:55
 55:       (x: void); // error
            ^ Cannot cast `x` to undefined because number literal `1` [1] is incompatible with undefined [2].
  References:
   53:     if (x === 1) {
                     ^ [1]: number literal `1`
   55:       (x: void); // error
                 ^^^^ [2]: undefined

Error: number.js:63
 63:     return x.foo; // error
                ^^^^^ Cannot return `x.foo` because number [1] is incompatible with number literal `0` [2].
  References:
   59:   function(x: { foo: number }): 0 {
                            ^^^^^^ [1]: number
   59:   function(x: { foo: number }): 0 {
                                       ^ [2]: number literal `0`

Error: number.js:97
 97:       return s; // error
                  ^ Cannot return `s` because number literal `3` [1] is incompatible with number enum [2].
  References:
   93:   function(s: number): ?Mode {
                     ^^^^^^ [1]: number literal `3`
   93:   function(s: number): ?Mode {
                               ^^^^ [2]: number enum

Error: number.js:116
116:       return x; // error
                  ^ Cannot return `x` because number [1] is incompatible with number literal `0` [2].
  References:
  114:   function(x: number): 0 {
                     ^^^^^^ [1]: number
  114:   function(x: number): 0 {
                              ^ [2]: number literal `0`

Error: property.js:71
 71:     return x[y.z];  // error
                ^^^^^^ Cannot return `x[y.z]` because null or undefined [1] is incompatible with string [2].
  References:
   68: function c2(x: {[key: string]: ?string}, y: {z: string}): string {
                                      ^^^^^^^ [1]: null or undefined
   68: function c2(x: {[key: string]: ?string}, y: {z: string}): string {
                                                                 ^^^^^^ [2]: string

Error: refinements.js:4
  4:         var y:string = x;
                            ^ Cannot assign `x` to `y` because number [1] is incompatible with string [2].
  References:
    2:     var x = b? 0 : null;
                      ^ [1]: number
    4:         var y:string = x;
                     ^^^^^^ [2]: string

Error: refinements.js:7
  7:     var z:string = x;
                        ^ Cannot assign `x` to `z` because boolean [1] is incompatible with string [2].
  References:
    5:         x = false;
                   ^^^^^ [1]: boolean
    7:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:7
  7:     var z:string = x;
                        ^ Cannot assign `x` to `z` because null [1] is incompatible with string [2].
  References:
    2:     var x = b? 0 : null;
                          ^^^^ [1]: null
    7:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:13
 13:         var y:string = x;
                            ^ Cannot assign `x` to `y` because null [1] is incompatible with string [2].
  References:
   11:     var x = b? 0 : null;
                          ^^^^ [1]: null
   13:         var y:string = x;
                     ^^^^^^ [2]: string

Error: refinements.js:13
 13:         var y:string = x;
                            ^ Cannot assign `x` to `y` because number [1] is incompatible with string [2].
  References:
   11:     var x = b? 0 : null;
                      ^ [1]: number
   13:         var y:string = x;
                     ^^^^^^ [2]: string

Error: refinements.js:16
 16:     var z:string = x;
                        ^ Cannot assign `x` to `z` because boolean [1] is incompatible with string [2].
  References:
   14:         x = false;
                   ^^^^^ [1]: boolean
   16:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:33
 33:         var y:number = x;
                            ^ Cannot assign `x` to `y` because string [1] is incompatible with number [2].
  References:
   24:         x = "hello";
                   ^^^^^^^ [1]: string
   33:         var y:number = x;
                     ^^^^^^ [2]: number

Error: refinements.js:33
 33:         var y:number = x;
                            ^ Cannot assign `x` to `y` because string [1] is incompatible with number [2].
  References:
   27:         x = "hello";
                   ^^^^^^^ [1]: string
   33:         var y:number = x;
                     ^^^^^^ [2]: number

Error: refinements.js:36
 36:     var z:string = x;
                        ^ Cannot assign `x` to `z` because number [1] is incompatible with string [2].
  References:
   34:         x = 42;
                   ^^ [1]: number
   36:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:43
 43:         var y:string = x;
                            ^ Cannot assign `x` to `y` because number [1] is incompatible with string [2].
  References:
   40:     for (var x = b? 0 : null;
                           ^ [1]: number
   43:         var y:string = x;
                     ^^^^^^ [2]: string

Error: refinements.js:45
 45:     var z:string = x;
                        ^ Cannot assign `x` to `z` because boolean [1] is incompatible with string [2].
  References:
   42:          x = false) {
                    ^^^^^ [1]: boolean
   45:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:45
 45:     var z:string = x;
                        ^ Cannot assign `x` to `z` because null [1] is incompatible with string [2].
  References:
   40:     for (var x = b? 0 : null;
                               ^^^^ [1]: null
   45:     var z:string = x;
                 ^^^^^^ [2]: string

Error: refinements.js:54
 54:     var z:number = x;
                        ^ Cannot assign `x` to `z` because boolean [1] is incompatible with number [2].
  References:
   50:     var x = false;
                   ^^^^^ [1]: boolean
   54:     var z:number = x;
                 ^^^^^^ [2]: number

Error: string.js:8
  8:       (x: void); // error
            ^ Cannot cast `x` to undefined because string literal `foo` [1] is incompatible with undefined [2].
  References:
    6:   function(x: string) {
                     ^^^^^^ [1]: string literal `foo`
    8:       (x: void); // error
                 ^^^^ [2]: undefined

Error: string.js:10
 10:     (x: 'foo'); // error
          ^ Cannot cast `x` to string literal `foo` because string [1] is incompatible with string literal `foo` [2].
  References:
    6:   function(x: string) {
                     ^^^^^^ [1]: string
   10:     (x: 'foo'); // error
               ^^^^^ [2]: string literal `foo`

Error: string.js:15
 15:       (x: 'foo'); // error
            ^ Cannot cast `x` to string literal `foo` because string [1] is incompatible with string literal `foo` [2].
  References:
   13:   function(x: string) {
                     ^^^^^^ [1]: string
   15:       (x: 'foo'); // error
                 ^^^^^ [2]: string literal `foo`

Error: string.js:17
 17:     (x: void); // error
          ^ Cannot cast `x` to undefined because string [1] is incompatible with undefined [2].
  References:
   13:   function(x: string) {
                     ^^^^^^ [1]: string
   17:     (x: void); // error
               ^^^^ [2]: undefined

Error: string.js:21
 21:     if (x === 'foo') {
                   ^^^^^ string literal `foo` [1] is incompatible with string literal `bar` [2].
  References:
   21:     if (x === 'foo') {
                     ^^^^^ [1]: string literal `foo`
   20:   function(x: 'bar'): 'foo' {
                     ^^^^^ [2]: string literal `bar`

Error: string.js:28
 28:     if (x === 'bar') {
                   ^^^^^ string literal `bar` [1] is incompatible with string literal `foo` [2].
  References:
   28:     if (x === 'bar') {
                     ^^^^^ [1]: string literal `bar`
   27:   function(x: 'foo'): string {
                     ^^^^^ [2]: string literal `foo`

Error: string.js:35
 35:     if (x !== 'bar') {
                   ^^^^^ string literal `bar` [1] is incompatible with string literal `foo` [2].
  References:
   35:     if (x !== 'bar') {
                     ^^^^^ [1]: string literal `bar`
   34:   function(x: 'foo') {
                     ^^^^^ [2]: string literal `foo`

Error: string.js:51
 51:       (x: void); // error
            ^ Cannot cast `x` to undefined because string literal `foo` [1] is incompatible with undefined [2].
  References:
   48:   function(x: 'foo' | 'bar') {
                     ^^^^^ [1]: string literal `foo`
   51:       (x: void); // error
                 ^^^^ [2]: undefined

Error: string.js:51
 51:       (x: void); // error
            ^ Cannot cast `x` to undefined because string literal `foo` [1] is incompatible with undefined [2].
  References:
   49:     if (x === 'foo') {
                     ^^^^^ [1]: string literal `foo`
   51:       (x: void); // error
                 ^^^^ [2]: undefined

Error: string.js:55
 55:       (x: void); // error
            ^ Cannot cast `x` to undefined because string literal `bar` [1] is incompatible with undefined [2].
  References:
   48:   function(x: 'foo' | 'bar') {
                             ^^^^^ [1]: string literal `bar`
   55:       (x: void); // error
                 ^^^^ [2]: undefined

Error: string.js:55
 55:       (x: void); // error
            ^ Cannot cast `x` to undefined because string literal `bar` [1] is incompatible with undefined [2].
  References:
   53:     if (x === 'bar') {
                     ^^^^^ [1]: string literal `bar`
   55:       (x: void); // error
                 ^^^^ [2]: undefined

Error: string.js:63
 63:     return x.foo; // error
                ^^^^^ Cannot return `x.foo` because string [1] is incompatible with string literal `foo` [2].
  References:
   59:   function(x: { foo: string }): 'foo' {
                            ^^^^^^ [1]: string
   59:   function(x: { foo: string }): 'foo' {
                                       ^^^^^ [2]: string literal `foo`

Error: string.js:98
 98:       return s; // error
                  ^ Cannot return `s` because string literal `d` [1] is incompatible with string enum [2].
  References:
   94:   function(s: string): ?Mode {
                     ^^^^^^ [1]: string literal `d`
   94:   function(s: string): ?Mode {
                               ^^^^ [2]: string enum

Error: string.js:117
117:       return x; // error
                  ^ Cannot return `x` because string [1] is incompatible with empty string [2].
  References:
  115:   function(x: string): "" {
                     ^^^^^^ [1]: string
  115:   function(x: string): "" {
                              ^^ [2]: empty string

Error: super_member.js:13
 13:       return super.prop; // error, unknown type passed to string expected
                  ^^^^^^^^^^ Cannot return `super.prop` because property `prop` of unknown type [1] is incompatible with string [2].
  References:
   12:     if (super.prop) { // super.prop doesn't exist
               ^^^^^^^^^^ [1]: property `prop` of unknown type
   11:   test(): string {
                 ^^^^^^ [2]: string

Error: switch.js:8
  8:       return text; // error, should return string
                  ^^^^ Cannot return `text` because number [1] is incompatible with string [2].
  References:
    3: function foo(text: string | number): string {
                                   ^^^^^^ [1]: number
    3: function foo(text: string | number): string {
                                            ^^^^^^ [2]: string

Error: switch.js:27
 27:       return text[0]; // error, [0] on number
                  ^^^^^^^ Cannot get `text[0]` because an indexer property is missing in `Number` [1].
  References:
   23: function baz1(text: string | number): string {
                                    ^^^^^^ [1]: `Number`

Error: switch.js:37
 37:       return text[0]; // error, [0] on number
                  ^^^^^^^ Cannot get `text[0]` because an indexer property is missing in `Number` [1].
  References:
   33: function baz2(text: string | number): string {
                                    ^^^^^^ [1]: `Number`

Error: switch.js:51
 51:       return (text++) + '';
                   ^^^^ string. The operand of an arithmetic operation must be a number.

Error: tagged_union.js:20
 20:     return x.prop1.charAt(0); // typeAST: Node1, but x.prop1 may be undefined
                        ^^^^^^ Cannot call `x.prop1.charAt` because property `charAt` is missing in undefined [1].
  References:
    3:   prop1?: string
                 ^^^^^^ [1]: undefined. See: ast_node.js:3

Error: tagged_union.js:34
 34:   if (x.kind === 'Fruit') { (x.taste: 'Good'); } // error, Apple.taste = Bad
                                  ^^^^^^^ Cannot cast `x.taste` to string literal `Good` because string literal `Bad` [1] is incompatible with string literal `Good` [2].
  References:
   26: type Apple = { kind: 'Fruit', taste: 'Bad' }
                                            ^^^^^ [1]: string literal `Bad`
   34:   if (x.kind === 'Fruit') { (x.taste: 'Good'); } // error, Apple.taste = Bad
                                             ^^^^^^ [2]: string literal `Good`

Error: tagged_union.js:35
 35:   else (x.raw: 'No'); // error, Carrot.raw = Maybe
             ^^^^^ Cannot cast `x.raw` to string literal `No` because string literal `Maybe` [1] is incompatible with string literal `No` [2].
  References:
   29: type Carrot = { kind: 'Veg', taste: 'Good', raw: 'Maybe' }
                                                        ^^^^^^^ [1]: string literal `Maybe`
   35:   else (x.raw: 'No'); // error, Carrot.raw = Maybe
                      ^^^^ [2]: string literal `No`

Error: tagged_union.js:40
 40:     (x.raw: 'Yes' | 'No'); // 2 errors:
          ^^^^^ Cannot cast `x.raw` to union type because string literal `Maybe` [1] is incompatible with string enum [2].
  References:
   29: type Carrot = { kind: 'Veg', taste: 'Good', raw: 'Maybe' }
                                                        ^^^^^^^ [1]: string literal `Maybe`
   40:     (x.raw: 'Yes' | 'No'); // 2 errors:
                   ^^^^^^^^^^^^ [2]: string enum

Error: tagged_union.js:40
 40:     (x.raw: 'Yes' | 'No'); // 2 errors:
            ^^^ Cannot get `x.raw` because property `raw` is missing in `Orange` [1].
  References:
   38: function qux(x: Breakfast) {
                       ^^^^^^^^^ [1]: `Orange`

Error: tagged_union.js:72
 72:   default: return x.A; // error, x: C and property A not found in type C
                         ^ Cannot get `x.A` because property `A` is missing in `C` [1].
  References:
   68: function kind(x: A | B | C): number {
                                ^ [1]: `C`

Error: tagged_union.js:89
 89:       (x.kindTypo: string); // typos can't be used, though
            ^^^^^^^^^^ Cannot cast `x.kindTypo` to string because number literal `1` [1] is incompatible with string [2].
  References:
   88:     if (x.kindTypo === 1) { // typos are allowed to be tested
               ^^^^^^^^^^ [1]: number literal `1`
   89:       (x.kindTypo: string); // typos can't be used, though
                          ^^^^^^ [2]: string

Error: tagged_union.js:96
 96:     if (x.fooTypo.bar === 1) {} // error, fooTypo doesn't exist
               ^^^^^^^ Cannot get `x.fooTypo` because property `fooTypo` is missing in object type [1].
  References:
   94:   function test8(x: {foo: {bar: 1}}) {
                           ^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:101
101:     if (x.kind === (null).toString()) {} // error, method on null
                               ^^^^^^^^ Cannot call `null.toString` because property `toString` is missing in null [1].
  References:
  101:     if (x.kind === (null).toString()) {} // error, method on null
                           ^^^^ [1]: null

Error: tagged_union.js:102
102:     if ({kind: 1}.kind === (null).toString()) {} // error, method on null
                                       ^^^^^^^^ Cannot call `null.toString` because property `toString` is missing in null [1].
  References:
  102:     if ({kind: 1}.kind === (null).toString()) {} // error, method on null
                                   ^^^^ [1]: null

Error: tagged_union.js:113
113:       (x.legnth: string); // error: number literal 0 !~> string
            ^^^^^^^^ Cannot cast `x.legnth` to string because number literal `0` [1] is incompatible with string [2].
  References:
  111:     if (x.legnth === 0) { // typos are allowed to be tested
               ^^^^^^^^ [1]: number literal `0`
  113:       (x.legnth: string); // error: number literal 0 !~> string
                        ^^^^^^ [2]: string

Error: tagged_union.js:118
118:       (y.legnth: string); // error: number literal 0 !~> string
            ^^^^^^^^ Cannot cast `y.legnth` to string because number literal `0` [1] is incompatible with string [2].
  References:
  116:     if (y.legnth === 0) { // typos are allowed to be tested
               ^^^^^^^^ [1]: number literal `0`
  118:       (y.legnth: string); // error: number literal 0 !~> string
                        ^^^^^^ [2]: string

Error: tagged_union.js:123
123:       (z.toStirng: string); // error: number literal 0 !~> string
            ^^^^^^^^^^ Cannot cast `z.toStirng` to string because number literal `0` [1] is incompatible with string [2].
  References:
  121:     if (z.toStirng === 0) { // typos are allowed to be tested
               ^^^^^^^^^^ [1]: number literal `0`
  123:       (z.toStirng: string); // error: number literal 0 !~> string
                          ^^^^^^ [2]: string

Error: tagged_union.js:128
128:       (q.valeuOf: string); // error: number literal 0 !~> string
            ^^^^^^^^^ Cannot cast `q.valeuOf` to string because number literal `0` [1] is incompatible with string [2].
  References:
  126:     if (q.valeuOf === 0) { // typos are allowed to be tested
               ^^^^^^^^^ [1]: number literal `0`
  128:       (q.valeuOf: string); // error: number literal 0 !~> string
                         ^^^^^^ [2]: string

Error: tagged_union.js:146
146:       (x.str: 'not str'); // error: 'str' !~> 'not str'
            ^^^^^ Cannot cast `x.str` to string literal `not str` because string literal `str` [1] is incompatible with string literal `not str` [2].
  References:
  145:     if (x.str === 'str') {
               ^^^^^ [1]: string literal `str`
  146:       (x.str: 'not str'); // error: 'str' !~> 'not str'
                     ^^^^^^^^^ [2]: string literal `not str`

Error: tagged_union.js:149
149:       (x.num: 456); // error: 123 !~> 456
            ^^^^^ Cannot cast `x.num` to number literal `456` because number literal `123` [1] is incompatible with number literal `456` [2].
  References:
  148:     if (x.num === 123) {
               ^^^^^ [1]: number literal `123`
  149:       (x.num: 456); // error: 123 !~> 456
                     ^^^ [2]: number literal `456`

Error: tagged_union.js:152
152:       (x.bool: false); // error: true !~> false
            ^^^^^^ Cannot cast `x.bool` to boolean literal `false` because boolean literal `true` [1] is incompatible with boolean literal `false` [2].
  References:
  151:     if (x.bool === true) {
               ^^^^^^ [1]: boolean literal `true`
  152:       (x.bool: false); // error: true !~> false
                      ^^^^^ [2]: boolean literal `false`

Error: tagged_union.js:156
156:       (x.badStr: empty); // error: 'bad' !~> empty
            ^^^^^^^^ Cannot cast `x.badStr` to empty because string literal `bad` [1] is incompatible with empty [2].
  References:
  155:     if (x.badStr === 'bad') {
               ^^^^^^^^ [1]: string literal `bad`
  156:       (x.badStr: empty); // error: 'bad' !~> empty
                        ^^^^^ [2]: empty

Error: tagged_union.js:159
159:       (x.badNum: empty); // error: 123 !~> empty
            ^^^^^^^^ Cannot cast `x.badNum` to empty because number literal `123` [1] is incompatible with empty [2].
  References:
  158:     if (x.badNum === 123) {
               ^^^^^^^^ [1]: number literal `123`
  159:       (x.badNum: empty); // error: 123 !~> empty
                        ^^^^^ [2]: empty

Error: tagged_union.js:162
162:       (x.badBool: empty); // error: true !~> empty
            ^^^^^^^^^ Cannot cast `x.badBool` to empty because boolean literal `true` [1] is incompatible with empty [2].
  References:
  161:     if (x.badBool === true) {
               ^^^^^^^^^ [1]: boolean literal `true`
  162:       (x.badBool: empty); // error: true !~> empty
                         ^^^^^ [2]: empty

Error: tagged_union.js:170
170:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  167:   function(x: { foo: 123, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:173
173:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  167:   function(x: { foo: 123, y: string } | { foo: 'foo', z: string }) {
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:177
177:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  167:   function(x: { foo: 123, y: string } | { foo: 'foo', z: string }) {
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:180
180:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  167:   function(x: { foo: 123, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:188
188:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  185:   function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:190
190:       x.y; // error: x.foo could be a string
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  185:   function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:191
191:       x.z; // error: could still be either case (if foo was a different number)
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  185:   function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:196
196:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  185:   function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:199
199:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  185:   function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:207
207:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:209
209:       x.y; // error: x.foo could be a string
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:210
210:       x.z; // error: could still be either case (if foo was a different number)
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:215
215:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:217
217:       x.y; // error: x.foo could be a different string
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:218
218:       x.z; // error: x.foo could be a number
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  204:   function(x: { foo: number, y: string } | { foo: string, z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:228
228:       x.y; // error: flow isn't smart enough to figure this out yet
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  224:     x: { foo: number, y: string } | { foo: string, z: string },
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:229
229:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  224:     x: { foo: number, y: string } | { foo: string, z: string },
              ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:237
237:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  234:   function(x: { foo: null, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:240
240:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  234:   function(x: { foo: null, y: string } | { foo: 'foo', z: string }) {
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:244
244:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  234:   function(x: { foo: null, y: string } | { foo: 'foo', z: string }) {
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:247
247:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  234:   function(x: { foo: null, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:255
255:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  252:   function(x: { foo: void, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:258
258:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  252:   function(x: { foo: void, y: string } | { foo: 'foo', z: string }) {
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:262
262:       x.y; // error
             ^ Cannot get `x.y` because property `y` is missing in object type [1].
  References:
  252:   function(x: { foo: void, y: string } | { foo: 'foo', z: string }) {
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: tagged_union.js:265
265:       x.z; // error
             ^ Cannot get `x.z` because property `z` is missing in object type [1].
  References:
  252:   function(x: { foo: void, y: string } | { foo: 'foo', z: string }) {
                     ^^^^^^^^^^^^^^^^^^^^^^^^ [1]: object type

Error: typeof.js:5
  5:     x[0]; // error for boolean, not number
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Boolean` [1].
  References:
    3: function foo(x: bool | number) {
                       ^^^^ [1]: `Boolean`

Error: typeof.js:12
 12:     return x; // error, null
                ^ Cannot return `x` because null [1] is incompatible with number [2].
  References:
   10:   var x = null;
                 ^^^^ [1]: null
    9: function bar(): number {
                       ^^^^^^ [2]: number

Error: typeof.js:23
 23:   BAZ.stuff(123); // error, refinement is gone
           ^^^^^ Cannot call `BAZ.stuff` because undefined [1] is not a function.
  References:
    3: declare var BAZ: {stuff?: (x: number) => void} | void;
                                 ^^^^^^^^^^^^^^^^^^^ [1]: undefined. See lib: lib.js:3

Error: typeof.js:23
 23:   BAZ.stuff(123); // error, refinement is gone
           ^^^^^ Cannot call `BAZ.stuff` because property `stuff` is missing in undefined [1].
  References:
    3: declare var BAZ: {stuff?: (x: number) => void} | void;
                                                        ^^^^ [1]: undefined. See lib: lib.js:3

Error: typeof.js:26
 26:   BAZ.stuff; // error, could be undefined
           ^^^^^ Cannot get `BAZ.stuff` because property `stuff` is missing in undefined [1].
  References:
    3: declare var BAZ: {stuff?: (x: number) => void} | void;
                                                        ^^^^ [1]: undefined. See lib: lib.js:3

Error: typeof.js:30
 30:     BAZ.stuff(123); // error, refinement is gone
             ^^^^^ Cannot call `BAZ.stuff` because undefined [1] is not a function.
  References:
    3: declare var BAZ: {stuff?: (x: number) => void} | void;
                                 ^^^^^^^^^^^^^^^^^^^ [1]: undefined. See lib: lib.js:3

Error: typeof.js:49
 49:   if (typeof x === "foo") { // error
                        ^^^^^ Cannot compare the result of `typeof` to string literal `foo` because it is not a valid `typeof` return value.

Error: typeof.js:61
 61:   if (typeof x === `foo`) { // error
                        ^^^^^ Cannot compare the result of `typeof` to string literal `foo` because it is not a valid `typeof` return value.

Error: typeof.js:69
 69:     (Foo: empty); // error, Foo is a class
          ^^^ Cannot cast `Foo` to empty because statics of `Foo` [1] is incompatible with empty [2].
  References:
   67:   class Foo {}
               ^^^ [1]: statics of `Foo`
   69:     (Foo: empty); // error, Foo is a class
                 ^^^^^ [2]: empty

Error: typeof.js:77
 77:     (x: empty); // error
          ^ Cannot cast `x` to empty because `Foo` [1] is incompatible with empty [2].
  References:
   75:   let x = new Foo();
                 ^^^^^^^^^ [1]: `Foo`
   77:     (x: empty); // error
               ^^^^^ [2]: empty

Error: undef.js:31
 31:     var y = x * 1000;
                 ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:38
 38:     var y = x * 1000;
                 ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:44
 44:     var y = x.x * 1000;
                 ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:51
 51:     var y = x.x * 1000;
                 ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:69
 69:     var b = y * 1000; // error
                 ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:74
 74:   if (100 * undefined) {
                 ^^^^^^^^^ undefined. The operand of an arithmetic operation must be a number.

Error: undef.js:77
 77:   if (undefined * 100) {
           ^^^^^^^^^ undefined. The operand of an arithmetic operation must be a number.

Error: union.js:7
  7:     x[0]; // error on boolean
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Boolean` [1].
  References:
  103: declare class Boolean {
                     ^^^^^^^ [1]: `Boolean`. See lib: <BUILTINS>/core.js:103

Error: union.js:13
 13:     x[0]; // error on number
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Number` [1].
  References:
   11: function bar(x: thing) {
                       ^^^^^ [1]: `Number`

Error: union.js:19
 19:     x[0]; // error on number
         ^^^^ Cannot get `x[0]` because an indexer property is missing in `Number` [1].
  References:
   17: function baz(x: ?thing) {
                        ^^^^^ [1]: `Number`

Error: void.js:31
 31:     var y = x * 1000;
                 ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:38
 38:     var y = x * 1000;
                 ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:44
 44:     var y = x.x * 1000;
                 ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:51
 51:     var y = x.x * 1000;
                 ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:56
 56:   if (x !== null && x !== void(x * 1000)) {
                                    ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:62
 62:   if (x === null || x === void(x * 1000)) {
                                    ^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:69
 69:   if (x.x !== null && x.x !== void(x.x * 1000)) {
                                        ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:75
 75:   if (x.x === null || x.x === void(x.x * 1000)) {
                                        ^^^ null or undefined. The operand of an arithmetic operation must be a number.

Error: void.js:82
 82:   if (100 * void(0)) {
                 ^^^^^^^ undefined. The operand of an arithmetic operation must be a number.

Error: void.js:85
 85:   if (void(0) * 100) {
           ^^^^^^^ undefined. The operand of an arithmetic operation must be a number.


Found 189 errors
